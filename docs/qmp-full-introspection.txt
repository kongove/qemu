= Full introspection support for QMP =


== Purpose ==

Add a new monitor command for management to  query QMP schema
information, it returns a range of schema structs, which contain the
useful metadata to help management to check supported features, QMP
commands detail, etc.

== Usage ==

Json schema:
  { 'type': 'NameInfo', 'data': {'*name': 'str'} }
  { 'command': 'query-name', 'returns': 'NameInfo' }

Execute QMP command:

  { "execute": "query-qmp-schema" }

Returns:

  { "return": [
      {
          "name": "query-name",
          "type": "command",
          "returns": {
              "name": "NameInfo",
              "type": "type",
              "data": [
                  {
                      "name": "name",
                      "optional": true,
                      "recursive": false,
                      "type": "str"
                  }
              ]
          }
      },
      ...
   }

The whole schema information will be returned in one go, it contains
all the schema entries. It doesn't support to be filtered by type
or name. Currently it takes about 4 seconds to return about 1.7M string.
Management only needs to execute this command once after installing
QEMU package.

== 'DataObject' union ==

{ 'union': 'DataObject',
  'base': 'DataObjectBase',
  'discriminator': 'type',
  'data': {
    'anonymous-struct': 'DataObjectAnonymousStruct',
    'command': 'DataObjectCommand',
    'enumeration': 'DataObjectEnumeration',
    'reference-type': 'String',
    'type': 'DataObjectType',
    'unionobj': 'DataObjectUnion' } }

Currently we have schema difinitions for type, command, enumeration,
union. Some arbitrary structs (dictionary, list or string) and native
types are also used in the body of definitions.

Here we use "DataObject" union to abstract all above schema. We want
to provide more useful metadata, and used some enum/unions to indicate
the dynamic type. In the output, some simple data is processed too
unwieldy. In another side, some complex data is described clearly.
It's also caused by some limitation of QAPI infrastructure.

So we define 'DataObject' to be an union, it always has an object name
except anonymous struct.

'command', 'enumeration', 'type', 'unionobj' are common schema type,
'union' is a build-in type, so I used unionobj here.

'reference-type' will be used to describe native types and unextended
types.

'anonymous-struct' will be used to describe arbitrary structs
(dictionary, list or string).

== Avoid dead loop in recursive extending ==

We have four types (ImageInfo, BlockStats, PciDeviceInfo, ObjectData)
that uses themself in their own define data directly or indirectly,
we will not repeatedly extend them to avoid dead loop.

We use a 'parents List' to record the visit path, type name of each
extended node will be saved to the List.

Append type name to the list before extending, and remove type name
from the list after extending.

If the type name is already extended in parents List, we won't extend
it repeatedly for avoiding dead loop.

'recursive' indicates if the type is extended or not.
